{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Sample-descriptors","level":2,"type":"heading","text":"Sample descriptors"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When using "},{"type":"codeVoice","code":"loadRawSampleData()"},{"type":"text","text":" and "},{"type":"codeVoice","code":"loadCompressedSampleFile()"},{"type":"text","text":" to load individual samples, you will need to create instances of one of three Swift structure types as follows."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The structures are defined as C structs in "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Sampler_Typedefs.h"}]},{"type":"text","text":" (which lives in the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"AudioKit\/Core\/DunneCore\/Sampler"}]},{"type":"text","text":" folder in the main AudioKit repo). This file is simple enough to reproduce here:"}]},{"type":"codeListing","syntax":null,"code":["typedef struct","{","    int noteNumber;","    float noteHz;","    ","    int min_note, max_note;","    int min_vel, max_vel;","    ","    bool bLoop;","    float fLoopStart, fLoopEnd;","    float fStart, fEnd;","","} SampleDescriptor;","","typedef struct","{","    SampleDescriptor sd;","    ","    float sampleRateHz;","    bool bInterleaved;","    int nChannels;","    int nSamples;","    float *pData;","","} SampleDataDescriptor;","","typedef struct","{","    SampleDescriptor sd;","    ","    const char* path;","    ","} SampleFileDescriptor;"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"By the miracle of Swift\/Objective-C bridging (see "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/library\/content\/documentation\/Swift\/Conceptual\/BuildingCocoaApps\/InteractingWithCAPIs.html"},{"type":"text","text":"), each of these three structures is accessible from Swift as a similarly-named class, which you can create by simply providing values for all the properties, as you’ll see in the examples below."}]},{"anchor":"SampleDataDescriptor-and-loadRawSampleData","level":2,"type":"heading","text":"SampleDataDescriptor and loadRawSampleData()"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"SampleDataDescriptor"}]},{"type":"text","text":", which is required when calling "},{"type":"codeVoice","code":"loadRawSampleData()"},{"type":"text","text":", has an "},{"type":"emphasis","inlineContent":[{"type":"text","text":"SampleDescriptor"}]},{"type":"text","text":" property (as described above) plus several additional properties to provide all the information "},{"type":"strong","inlineContent":[{"type":"text","text":"Sampler"}]},{"type":"text","text":" needs about the sample:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"sampleRateHz"}]},{"type":"text","text":" is the sampling rate at which the sample data were acquired. If the sampler needs to play back the sample at a different rate, it will need to scale its playback rate based on the ratio of the two rates."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"nChannels"}]},{"type":"text","text":" will be 1 if the sample is monophonic, or 2 if stereo. Note the sampler can play back mono samples as stereo; it simply plays the same data to both output channels. (In the reverse case, only the Left channel data will sound.)"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"bInterleaved"}]},{"type":"text","text":" should be set "},{"type":"emphasis","inlineContent":[{"type":"text","text":"true"}]},{"type":"text","text":" only for stereo samples represented in memory as Left1, Right1, Left2, Right2, etc. Set "},{"type":"emphasis","inlineContent":[{"type":"text","text":"false"}]},{"type":"text","text":" for mono samples, or non-interleaved stereo samples where all the Left samples come first, followed by all the Right samples."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"pSamples"}]},{"type":"text","text":" is a pointer to the raw sample data; it has the slightly-scary Swift type "},{"type":"emphasis","inlineContent":[{"type":"text","text":"UnsafeMutablePointer<Float>"}]},{"type":"text","text":"."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s an example of creating a sample programmatically in Swift, and loading it using "},{"type":"codeVoice","code":"loadRawSampleData()"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":null,"code":["var myData = [Float](repeating: 0.0, count: 1000)","for i in 0..<1000 {","    myData[i] = sin(2.0 * Float(i)\/1000 * Float.pi)","}","let sampleRate = Float(Settings.sampleRate)","let desc = SampleDescriptor(noteNumber: 69,","                                  noteHz: sampleRate\/1000,","                                min_note: -1,","                                max_note: -1,","                                 min_vel: -1,","                                 max_vel: -1,","                                   bLoop: true,","                              fLoopStart: 0,","                                fLoopEnd: 1,","                                  fStart: 0,","                                    fEnd: 0)","let ptr = UnsafeMutablePointer<Float>(mutating: myData)","let ddesc = SampleDataDescriptor(sd: desc,","                         sampleRateHz: sampleRate,","                         bInterleaved: false,","                            nChannels: 1,","                             nSamples: 1000,","                                pData: ptr)","sampler.loadRawSampleData(sdd: ddesc)","sampler.setLoop(thruRelease: true)","sampler.buildSimpleKeyMap()"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A few points to note about this example:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"We get the scary-typed pointer by calling the pointer type’s "},{"type":"codeVoice","code":"init(mutating:)"},{"type":"text","text":" function"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Settings.sampleRate"},{"type":"text","text":" provides the current audio sampling rate"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Since we have only one note, the "},{"type":"codeVoice","code":"noteNumber"},{"type":"text","text":" can be anything"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"We can set "},{"type":"codeVoice","code":"min_note"},{"type":"text","text":" etc. to -1, because we call "},{"type":"codeVoice","code":"buildSimpleKeyMap()"},{"type":"text","text":" not "},{"type":"codeVoice","code":"buildKeyMap()"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"fLoopStart"},{"type":"text","text":" and "},{"type":"codeVoice","code":"fLoopEnd"},{"type":"text","text":" are normally sample counts (i.e., we could specify 0.0 and 999.0 to loop over the whole sample), but values between 0 and 1 are interpreted as "},{"type":"emphasis","inlineContent":[{"type":"text","text":"fractions"}]},{"type":"text","text":" of the full sample length. Hence we can just use 0 to mean “start of the sample” and 1 to mean “end of the sample”."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"setting "},{"type":"codeVoice","code":"fEnd"},{"type":"text","text":" to 0 also means “end of the sample”"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"To ensure the sampler keeps looping even after each note is released (very important with such short samples), we call "},{"type":"codeVoice","code":"setLoop(thruRelease: true)"},{"type":"text","text":"."}]}]}]},{"anchor":"SampleFileDescriptor-and-loadCompressedSampleFile","level":2,"type":"heading","text":"SampleFileDescriptor and loadCompressedSampleFile()"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"SampleFileDescriptor"}]},{"type":"text","text":", used in calls to "},{"type":"codeVoice","code":"loadCompressedSampleFile()"},{"type":"text","text":" is very simple. Like "},{"type":"emphasis","inlineContent":[{"type":"text","text":"SampleDataDescriptor"}]},{"type":"text","text":", it has an "},{"type":"emphasis","inlineContent":[{"type":"text","text":"SampleDescriptor"}]},{"type":"text","text":" property, to which it simply adds a "},{"type":"codeVoice","code":"String"},{"type":"text","text":" property "},{"type":"codeVoice","code":"path"},{"type":"text","text":". Here’s an example of using "},{"type":"codeVoice","code":"loadCompressedSampleFile()"},{"type":"text","text":", taken from the Sampler demo program:"}]},{"type":"codeListing","syntax":null,"code":["private func loadCompressed(baseURL: URL,","                         noteNumber: MIDINoteNumber,","                         folderName: String,","                         fileEnding: String,","                           min_note: Int32 = -1,","                           max_note: Int32 = -1,","                           min_vel: Int32 = -1,","                           max_vel: Int32 = -1)","{","    let folderURL = baseURL.appendingPathComponent(folderName)","    let fileName = folderName + fileEnding","    let fileURL = folderURL.appendingPathComponent(fileName)","    let freq = float(PolyphonicNode.tuningTable.frequency(forNoteNumber: noteNumber))","    let sd = SampleDescriptor(noteNumber: Int32(noteNumber),","                                    noteHz: freq,","                                  min_note: min_note,","                                  max_note: max_note,","                                   min_vel: min_vel,","                                   max_vel: max_vel,","                                     bLoop: true,","                                fLoopStart: 0.2,","                                  fLoopEnd: 0.3,","                                    fStart: 0.0,","                                      fEnd: 0.0)","    let fdesc = SampleFileDescriptor(sd: sd, path: fileURL.path)","    sampler.loadCompressedSampleFile(sfd: fdesc)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note in the last line of the code above, "},{"type":"codeVoice","code":"sampler"},{"type":"text","text":" is a "},{"type":"strong","inlineContent":[{"type":"text","text":"Sampler"}]},{"type":"text","text":" instance. See the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Conductor.swift"}]},{"type":"text","text":" file in the SamplerDemo macOS example for more context."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/dunneaudiokit\/sampler-descriptors"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/DunneAudioKit\/documentation\/DunneAudioKit\/Sampler-descriptors","interfaceLanguage":"swift"},"kind":"article","metadata":{"roleHeading":"Article","title":"Sampler initialisation with descriptors","role":"article","modules":[{"name":"DunneAudioKit"}]},"hierarchy":{"paths":[["doc:\/\/DunneAudioKit\/documentation\/DunneAudioKit"]]},"references":{"doc://DunneAudioKit/documentation/DunneAudioKit":{"role":"collection","title":"DunneAudioKit","abstract":[{"type":"text","text":"Chorus, Flanger, Sampler, Stereo Delay, and Synth for AudioKit, by Shane Dunne."}],"identifier":"doc:\/\/DunneAudioKit\/documentation\/DunneAudioKit","kind":"symbol","type":"topic","url":"\/documentation\/dunneaudiokit"},"https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html":{"title":"Using Swift with Cocoa and Objective-C","titleInlineContent":[{"type":"text","text":"Using Swift with Cocoa and Objective-C"}],"type":"link","identifier":"https:\/\/developer.apple.com\/library\/content\/documentation\/Swift\/Conceptual\/BuildingCocoaApps\/InteractingWithCAPIs.html","url":"https:\/\/developer.apple.com\/library\/content\/documentation\/Swift\/Conceptual\/BuildingCocoaApps\/InteractingWithCAPIs.html"}}}